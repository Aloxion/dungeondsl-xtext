/*
 * generated by Xtext 2.37.0
 */
package org.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import org.xtext.dungeonDSL.Dungeon;
import org.xtext.dungeonDSL.Floor;
import org.xtext.dungeonDSL.Room;
import org.xtext.dungeonDSL.Trap;
import java.lang.reflect.Array
import java.util.ArrayList
import org.eclipse.emf.common.util.EList;
import org.xtext.dungeonDSL.BinaryOperation
import org.xtext.dungeonDSL.NumberLiteral

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DungeonDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        
        val dungeon = resource.allContents.toIterable.filter(Dungeon).head
        
        
        if (dungeon !== null) {
            // Generate JSON file with same name as the dungeon
            val fileName = dungeon.name + ".py"
            fsa.generateFile(fileName, generateDungeon(dungeon))
        }
        
    }
    
	def generateDungeon(Dungeon dungeon) '''
# usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Generated Dungeon: «escape(dungeon.name)»
Theme: «escape(dungeon.theme)»
"""	 
import pygame
from enum import Enum
from typing import List, Optional
import random


class Sizes(Enum):
    LARGE = "LARGE"
    MEDIUM = "MEDIUM"
    SMALL = "SMALL"


class RoomTypes(Enum):
    COMBAT = "COMBAT"
    TREASURE = "TREASURE"
    BOSS = "BOSS"
    PUZZLE = "PUZZLE"
    SHOP = "SHOP"


class EventTrigger(Enum):
    STEP_ON = "stepOn"
    OPEN_DOOR = "openDoor"


class Behaviour(Enum):
    AGGRESSIVE = "AGGRESSIVE"
    NEUTRAL = "NEUTRAL"


class NPCType(Enum):
    MERCHANT = "MERCHANT"
    ENEMY = "ENEMY"
    NORMAL = "NORMAL"


class Dungeon:
    def __init__(self, name: str, theme: str, lvl: int):
        self.name = name
        self.theme = theme
        self.lvl = lvl
        self.floors: List[Dungeon.Floor] = []

    def add_floor(self, floor):
        self.floors.append(floor)

    class Floor:
        def __init__(self, name: str):
            self.name = name
            self.rooms: List[Dungeon.Room] = []

        def add_room(self, room):
            self.rooms.append(room)

        def get_room_by_name(self, name: str) -> Optional["Dungeon.Room"]:
            for room in self.rooms:
                if room.name == name:
                    return room
            return None

    class Room:
        def __init__(
            self,
            name: str,
            size: Sizes,
            room_type: RoomTypes,
            floor_id: str,
        ):
            self.name = name
            self.size = size
            self.room_type = room_type
            self.floor_id = floor_id
            self.connections = []
            self.traps: List[Dungeon.Trap] = []
            self.npcs: List[Dungeon.NPC] = []

        def add_trap(self, trap):
            self.traps.append(trap)

        def set_connections(self, connections):
            self.connections = connections
		
        def add_npc(self, npc):
            self.npcs.append(npc)

    class Trap:
        def __init__(
            self,
            name: str,
            trigger: EventTrigger,
            disarmable: bool,
            trigger_chance: int,
        ):
            self.name = name
            self.trigger = trigger
            self.disarmable = disarmable
            self.trigger_chance = trigger_chance

    class NPC:
        def __init__(
            self, name: str, behaviour: Behaviour, npc_type: NPCType, health: int
        ):
            self.name = name
            self.behaviour = behaviour
            self.npc_type = npc_type
            self.health = health

dung = Dungeon("«escape(dungeon.name)»", "«escape(dungeon.theme)»", «dungeon.lvl»)

«FOR floor : dungeon.floors»
«floor.name» = Dungeon.Floor("«floor.name»")
dung.add_floor(«floor.name»)
	«FOR room : floor.rooms»

«room.name»_«floor.name» = Dungeon.Room(
	     name="«room.name»",
	     size=Sizes.«room.size»,
	     room_type=RoomTypes.«room.type»,
	     floor_id=«floor.name»,
	)
«FOR npc : room.npcs»
«npc.name»_«room.name» = Dungeon.NPC(
		name="«npc.name»",
		behaviour=Behaviour.«npc.behaviour»,
		npc_type=NPCType.«npc.type»,
		health=«evaluate(npc.baseHealth)»
)
«room.name»_«floor.name».add_npc(«npc.name»_«room.name»)
«ENDFOR»

    «ENDFOR»
«ENDFOR»
«FOR floor : dungeon.floors»
    «FOR room : floor.rooms»
«floor.name».add_room(«room.name»_«floor.name»)
«room.name»_«floor.name».set_connections([
	«FOR connection : room.connections SEPARATOR ','»
«getConnectedRoomName(connection, floor, dungeon.floors)»
	«ENDFOR»
]
)
	«ENDFOR»
«ENDFOR»



# Pygame visualization
pygame.init()
# Colors
WHITE = (255, 255, 255)
BLACK = (34, 34, 34)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
CUSTOM = (190, 222, 252)
# Screen dimensions
WIDTH, HEIGHT = 1920, 1020
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Dungeon Visualization")

biggestWidth = max(len(room.name) for room in dung.floors[0].rooms) * 7.5


def sort_rooms_by_connections(rooms):
    room_tree = {}
    roomsHandled = []
    sorted_rooms = sorted(rooms, key=lambda x: len(x.connections), reverse=True)

    for firstRoom in sorted_rooms:
        if firstRoom.name not in room_tree and firstRoom.name not in roomsHandled:
            room_tree[firstRoom.name] = firstRoom.connections
            roomsHandled.append(firstRoom.name)
            for connectedRoom in firstRoom.connections:
                roomsHandled.append(connectedRoom.name)
            continue

    return room_tree


def generate_room_positions(rooms):
    room_positions = {}
    center_x = WIDTH // 2
    center_y = HEIGHT // 2
    x_increment = biggestWidth * 1.2
    y_increment = biggestWidth * 1.2

    # Create a grid
    grid_width = WIDTH // int(x_increment) + 1
    grid_height = HEIGHT // int(y_increment) + 1
    grid = [[0 for _ in range(grid_height)] for _ in range(grid_width)]

    def get_grid_coords(x, y):
        grid_x = int(x // x_increment)
        grid_y = int(y // y_increment)
        return grid_x, grid_y

    def is_grid_available(x, y):
        grid_x, grid_y = get_grid_coords(x, y)
        if 0 <= grid_x < grid_width and 0 <= grid_y < grid_height:
            return grid[grid_x][grid_y] == 0
        return False

    def mark_grid_used(x, y):
        grid_x, grid_y = get_grid_coords(x, y)
        if 0 <= grid_x < grid_width and 0 <= grid_y < grid_height:
            grid[grid_x][grid_y] = 1

    first_room = rooms[0]
    room_positions[first_room.name] = (center_x, center_y)
    mark_grid_used(center_x, center_y)

    rooms_to_place = [(first_room, center_x, center_y)]
    placed_rooms = {first_room.name}

    while rooms_to_place:
        current_room, current_x, current_y = rooms_to_place.pop(0)
        connections = current_room.connections
    

        directions = {
            "top": (0, -y_increment),
            "bottom": (0, y_increment),
            "left": (-x_increment, 0),
            "right": (x_increment, 0),
        }
        opposite_directions = {
            "top": "bottom",
            "bottom": "top",
            "left": "right",
            "right": "left",
        }

        available_directions = list(directions.keys())
        random.shuffle(available_directions)

        for connected_room in connections:
            if connected_room not in rooms:
                continue
            if connected_room.name not in placed_rooms:
                chosen_direction = None
                for direction_name in available_directions:
                    dx, dy = directions[direction_name]
                    new_x, new_y = current_x + dx, current_y + dy
                    if is_grid_available(new_x, new_y):
                        chosen_direction = direction_name
                        break

                if chosen_direction is None:
                    for direction_name in available_directions:
                        dx, dy = directions[direction_name]
                        new_x, new_y = current_x + dx, current_y + dy
                        if (
                            is_grid_available(new_x, new_y)
                            and opposite_directions[direction_name]
                        ):
                            chosen_direction = direction_name
                            break

                if chosen_direction is None:
                    print(
                        f"Could not find a valid position for {connected_room.name}, skipping."
                    )
                    continue

                dx, dy = directions[chosen_direction]
                new_x, new_y = current_x + dx, current_y + dy
                room_positions[connected_room.name] = (new_x, new_y)
                mark_grid_used(new_x, new_y)
                rooms_to_place.append((connected_room, new_x, new_y))
                placed_rooms.add(connected_room.name)
                available_directions.remove(chosen_direction)

    return room_positions


# Replace the outer loop structure with this modified version
currentFloor = dung.floors[0]
current_room = currentFloor.rooms[0]
rooms_visited = {current_room}
undiscovered_rooms = {conn for conn in currentFloor.rooms[0].connections}
running = True
# Generate room positions for each floor once at the beginning
floor_room_positions = {}
floor_room_rects = {}
for floor in dung.floors:
    floor_room_positions[floor.name] = generate_room_positions(floor.rooms)

    # Create room rectangles for each floor
    room_rects = {}
    for room_name, position in floor_room_positions[floor.name].items():
        print(f"Room: {room_name}, Position: {position}")
        width = biggestWidth
        size = biggestWidth
        room_rects[room_name] = pygame.Rect(
            position[0] - width // 2, position[1] - size // 2, width, size
        )
    floor_room_rects[floor.name] = room_rects

button_rect = None

while running:
    # Use cached room positions and rectangles for current floor
    room_positions = floor_room_positions[currentFloor.name]
    room_rects = floor_room_rects[currentFloor.name]
    
    # Process events BEFORE rendering
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
            
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            # Check room clicks
            for room_name, rect in room_rects.items():
                if rect.collidepoint(event.pos):
                    print("Collided with room rect")
                    room = currentFloor.get_room_by_name(room_name)
                    current_room = room
                    if current_room not in rooms_visited:
                        rooms_visited.add(current_room)
                    
                    print(f"Clicked on room: {room.name}")       
                           
                    for connected_room in room.connections:
                        if connected_room not in rooms_visited:
                            undiscovered_rooms.add(connected_room)
                    break
                    
            # Check for floor transition button click
            if button_rect and button_rect.collidepoint(event.pos):
                # Find the destination floor and room
                for other_floor in dung.floors:
                    if other_floor != currentFloor:
                        for room in other_floor.rooms:
                            for connected_room in room.connections:
                                if connected_room == current_room:
                                    currentFloor = other_floor
                                    current_room = currentFloor.rooms[0]
                                    rooms_visited = {current_room}
                                    undiscovered_rooms = {conn for conn in current_room.connections}
                                    
                                    room_positions = floor_room_positions[currentFloor.name]
                                    room_rects = floor_room_rects[currentFloor.name]
                                    break
    
    # Clear screen
    screen.fill(color=BLACK)
    
    # Draw floor transition button
    current_room_obj = current_room
    if current_room_obj:
        for other_floor in dung.floors:
            if other_floor != currentFloor:
                for room in other_floor.rooms:
                    for connected_room in room.connections:
                        if connected_room == current_room:
                            button_width, button_height = 150, 50
                            button_x = WIDTH - button_width - 20
                            button_y = HEIGHT - button_height - 20
                            button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
                            pygame.draw.rect(screen, BLUE, button_rect, border_radius=5)
                            font = pygame.font.Font(None, 24)
                            text = font.render("Move to Floor", True, WHITE)
                            text_rect = text.get_rect(center=button_rect.center)
                            screen.blit(text, text_rect)
    
    # Draw connections
    for room in currentFloor.rooms:
        if room == current_room or room in rooms_visited:
            for connected_room in room.connections:
                if connected_room.name in room_positions and connected_room in currentFloor.rooms:
                    pygame.draw.line(
                        screen,
                        CUSTOM,
                        room_positions[room.name],
                        room_positions[connected_room.name],
                        2,
                    )

    # Draw rooms
    for room_name, position in room_positions.items():
        room = currentFloor.get_room_by_name(room_name)
        if room not in undiscovered_rooms and room not in rooms_visited:
            continue

        if room in rooms_visited:
            color = RED if room.room_type == RoomTypes.BOSS else CUSTOM
        else:
            color = WHITE
        if room == current_room:
            color = RED if room.room_type == RoomTypes.BOSS else GREEN
            
        width = biggestWidth
        size = biggestWidth
        pygame.draw.rect(
            screen,
            color,
            (position[0] - width // 2, position[1] - size // 2, width, size),
            border_radius=10,
        )
        
        font = pygame.font.Font(None, 16)
        if room in rooms_visited:
            text = font.render(room.name, True, BLACK)
        else:
            text = font.render("?", True, BLACK)  # Show "?" if not visited
        text_rect = text.get_rect(center=position)
        screen.blit(text, text_rect)

    # Update display
    pygame.display.flip()

pygame.quit()
'''
//
//    def generateTrapJson(Trap trap) 
//        {
//          "name": "«escape(trap.name)»",
//          "trigger": "«trap.trigger»",
//          "disarmable": «trap.disarmable»,
//          "triggerChance": «trap.triggerChance»
//        }
//    '''
    
    // Helper method to escape JSON strings
 
 	def getConnectedRoomName(String connectedName, Floor currentFloor, EList<Floor> floors) {
 		
 		for (room : currentFloor.rooms) {
 			
 			if (room.name == connectedName) {
 				return room.name + '_' + currentFloor.name
 			}
 		}
 		
 		for (floor : floors) {
 			
 			for (room : floor.rooms) {
 			
 				if (room.name == connectedName) {
 					return room.name + '_' + floor.name
 				}
 			}
 		}
 	}
    
    def dispatch int evaluate(NumberLiteral n) {
    	n.value
	}
	
	def dispatch int evaluate(BinaryOperation b) {
    val leftVal = b.left.evaluate
    val rightVal = b.right.evaluate
    switch b.operator {
        case '+': leftVal + rightVal
        case '-': leftVal - rightVal
        case '*': leftVal * rightVal
        case '/': leftVal / rightVal
        default: throw new IllegalArgumentException("Unknown operator: " + b.operator)
    }
}
    
    def escape(String s) {
        if (s === null) {
            return ""
        }
        
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t")
    }
     
}
